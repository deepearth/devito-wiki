# Frequently Asked Questions

- [How can I see the compilation command with which Devito compiles the generated code?](#How-can-I-see-the-compilation-command-with-which-Devito-compiles-the-generated-code?)

- [I create an Operator, look at the generated code, and the equations appear in a different order than I expected.](#I-create-an-Operator,-look-at-the-generated-code,-and-the-equations-appear-in-a-different-order-than-I-expected.)

- [Where does generated code go and how do I look at it](#Where-does-generated-code-go-and-how-do-I-look-at-it)

- [What environment variables control how devito works](#What-environment-variables-control-how-devito-works)

- [How do you run the unit tests from the command line](#How-do-you-run-the-unit-tests-from-the-command-line)

- [What is the difference between op() and op[] notation](#What-is-the-difference-between-op()-and-op[]-notation)

- [Is there a flow chart?](#Is-there-a-flow-chart?)

- [What's up with <object>.data](#What's-up-with-<object>.data)

- [What are the keys to fast code](#What-are-the-keys-to-fast-code)

- [How can I change the compilation flags (for example, I want to change the optimization level from -O3 to -O0)?](#How-can-I-change-the-compilation-flags-(for-example,-I-want-to-change-the-optimization-level-from--O3-to--O0)?)

- [Can I control the MPI domain decomposition?](#Can-I-control-the-MPI-domain-decomposition?)

- [Can I manually modify the C code generated by Devito and test these modifications?](#Can-I-manually-modify-the-C-code-generated-by-Devito-and-test-these-modifications?)


## How can I see the compilation command with which Devito compiles the generated code?

Set the environment variable `DEVITO_DEBUG_COMPILER=1`. When an Operator gets compiled, the used compilation command will be emitted to stdout. 

If nothing seems to change, it is possible that no compilation is happening under-the-hood as all kernels have already been compiled in a previous run. You will then have to clear up the Devito kernel cache. From the Devito root directory, run:
```
python scripts/clear_devito_cache.py
```

## I create an Operator, look at the generated code, and the equations appear in a different order than I expected.

The Devito compiler computes a topological ordering of the input equations based on data dependency analysis. Heuristically, some equations might be moved around to improve performance (e.g., data locality). Therefore, the order of the equations in the generated code might be different than that used as input to the Operator.


## Where does generated code go and how do I look at it
TMP variable?


## What environment variables control how devito works
You can get the list of environment variables with the following python code:
```
from devito import print_defaults                                                                                                                                                                               
print_defaults()                                                                                                                                                                                                
```
And the output: **[NOTE: need a description of each of these]**
```
DEVITO_ARCH: ['custom', 'gnu', 'gcc', 'clang', 'pgcc', 'pgi', 'osx', 'intel', 'icpc', 'icc', 'intel-knl', 'knl', 'gcc-4.9', 'gcc-5', 'gcc-6', 'gcc-7', 'gcc-8', 'gcc-9']. Default: custom
DEVITO_PLATFORM: ['cpu64-dummy', 'intel64', 'snb', 'ivb', 'hsw', 'bdw', 'skx', 'klx', 'clx', 'knl', 'knl7210', 'arm', 'power8', 'power9', 'nvidiaX', 'cpu64']. Default: cpu64
DEVITO_PROFILING: ['basic', 'advanced', 'advisor']. Default: basic
DEVITO_BACKEND: ['core', 'yask', 'void', 'ops']. Default: core
DEVITO_DEVELOP: [False, True]. Default: True
DEVITO_DSE: ['basic', 'advanced', 'aggressive']. Default: advanced
DEVITO_DLE: ['noop', 'advanced', ('noop', 'C'), ('advanced', 'C')]. Default: advanced
DEVITO_OPENMP: [0, 1]. Default: 0
DEVITO_MPI: [0, 1, 'basic', 'diag', 'overlap', 'overlap2', 'full']. Default: 0
DEVITO_AUTOTUNING: ['off', 'basic', 'aggressive', 'max', ['off', 'preemptive'], ['off', 'destructive'], ['off', 'runtime'], ['basic', 'preemptive'], ['basic', 'destructive'], ['basic', 'runtime'], ['aggressive', 'preemptive'], ['aggressive', 'destructive'], ['aggressive', 'runtime'], ['max', 'preemptive'], ['max', 'destructive'], ['max', 'runtime']]. Default: off
DEVITO_LOGGING: ['DEBUG', 'PERF', 'YASK', 'YASK_WARN', 'INFO', 'WARNING', 'ERROR', 'CRITICAL']. Default: INFO
DEVITO_FIRST_TOUCH: [0, 1]. Default: 0
DEVITO_DEBUG_COMPILER: [0, 1]. Default: 0
DEVITO_JIT_BACKDOOR: [0, 1]. Default: 0
DEVITO_IGNORE_UNKNOWN_PARAMS: [0, 1]. Default: 0
```

## How do you run the unit tests from the command line
```
Py.test <test.py>
Py.test -vs <test.py>  [more detailed log]
```

## What is the difference between op() and op[] notation
Bla bla ... indexify ... bla


## Is there a flow chart?
Simple flow chart for equation --> code, with links from each step to the API docs


## What's up with <object>.data
Bla bla numpy array backends


## What are the keys to fast code
CPU: Cache blocking, loop fusing, alignment to promote SIMD, ...
GPU: longer pipelines, less travel to host
As time increases in the finite difference evolution, are wavefield arrays "swapped" like you might see in c/c++ code?
No, devito uses the modulus of a time index to map increasing indices [0, 1, 2, 3, 4, 5, ...] into cyclic indices [0, 1, 2, 0, 1, 2, ...]
What are units typically used in devito examples
Sampling rates: msec
Frequency: KHz
Velocity: km/sec


## How can I change the compilation flags (for example, I want to change the optimization level from -O3 to -O0)?

There is currently no API to achieve this straightforwardly. However, there are three work arounds:

* hacky way: change the flags explicitly in the Devito source code. In Devito v4.0, you can do that [here](https://github.com/opesci/devito/blob/v4.0/devito/compiler.py#L146)
* via env vars: use a [CustomCompiler](https://github.com/opesci/devito/blob/v4.0/devito/compiler.py#L446) -- just leave the `DEVITO_ARCH` environment variable unset or set it to `'custom'`. Then, `export CFLAGS="..."` to tell Devito to use the exported flags in place of the default ones.
* programmatically: subclass one of the compiler classes and set `self.cflags` to whatever you need. Do not forget to add the subclass to the [compiler registry](https://github.com/opesci/devito/blob/v4.0/devito/compiler.py#L472). For example, you could do

```
from devito import configuration, compiler_registry
from devito.compiler import GNUCompiler

class MyOwnCompiler(GNUCompiler):
    def __init__(self, *args, **kwargs):
        super(MyOwnCompiler, self).__init__(*args, **kwargs)
        # <manipulate self.cflags here >

# Make sure Devito is aware of this new Compiler class
compiler_registry['mycompiler'] = MyOwnCompiler
configuration.add("compiler", "custom", list(compiler_registry), callback=lambda i: compiler_registry[i]())

# Then, what remains to be done is asking Devito to use MyOwnCompiler

configuration['compiler'] = 'mycompiler'
```

## Can I control the MPI domain decomposition?

Until Devito v3.5 included, domain decomposition occurs along the fastest axis. As of later versions, domain decomposition occurs along the slowest axis, for performance reasons.  And yes, it is possible to control the domain decomposition in user code, but this is undocumented and currently there exists no clean API to do that. However, below we provide some guidelines on how one can implement this.

* Start taking a look at the `Distributor` class, which controls the domain decomposition. In Devito v3.5, you can find it [here](https://github.com/opesci/devito/blob/v3.5/devito/mpi/distributed.py#L160).
* Turn the free function `compute_dims` into a `Distributor` method.
* In your user code, inherit from `Distributor` and override `compute_dims` at will. This will impact how the domain is decomposed along each of the distributed axes. 
* Change `Grid` to accept a `Distributor`, instead of `comm` (an MPI communicator). In Devito v3.5, you can do it [here](https://github.com/opesci/devito/blob/v3.5/devito/types/grid.py#L100).
* In your user code, create a `Grid` passing in an instance of the sub-classed `Distributor`, that is you should have `grid = Grid(...., distributor=MyDistributor(...))`.

## Can I manually modify the C code generated by Devito and test these modifications?

Yes, as of Devito v3.5 it is possible to modify the generated C code and run it inside Devito. First you need to get the C file generated for a given `Operator`. Run your code in `DEBUG` mode:
```
DEVITO_LOGGING=DEBUG python your_code.py
```
The generated code path will be shown as in the excerpt below:
```
CustomCompiler: compiled `/tmp/devito-jitcache-uid1000/ed41e9373af1bc129471b7ae45e1c3740b60a856.c` [0.29 s]
```
You can now open the C file, do the modifications you like, and save them. Finally, rerun the same program but this time with the _Devito JIT backdoor_ enabled:
```
DEVITO_JIT_BACKDOOR=1 python your_code.py
```
This will force Devito to recompile and link the modified C code.
