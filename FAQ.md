# Frequently Asked Questions

- [How can I see the compilation command with which Devito compiles the generated code?](#How-can-I-see-the-compilation-command-with-which-Devito-compiles-the-generated-code?)
- [Where does the generated code go and how do I look at it?](#Where-does-the-generated-code-go-and-how-do-I-look-at-it?)
- [Can I change the directory where Devito stashes the generated code?](#Can-I-change-the-directory-where-Devito-stashes-the-generated-code?)
- [I create an Operator, look at the generated code, and the equations appear in a different order than I expected.](#I-create-an-Operator,-look-at-the-generated-code,-and-the-equations-appear-in-a-different-order-than-I-expected.)
- [What environment variables control how Devito works](#What-environment-variables-control-how-devito-works)
- [How do you run the unit tests from the command line](#How-do-you-run-the-unit-tests-from-the-command-line)
- [What is the difference between f() and f[] notation?](#What-is-the-difference-between-op()-and-op[]-notation?)
- [What is the indexed notation?](#What-is-the-indexed-notation?)
- [Is there a flow chart?](#Is-there-a-flow-chart?)
- [What's up with <object>.data](#What's-up-with-<object>.data)
- [What are the keys to fast code](#What-are-the-keys-to-fast-code)
- [As time increases in the finite difference evolution, are wavefield arrays "swapped" as you might see in c/c++ code?](#As-time-increases-in-the-finite-difference-evolution,-are-wavefield-arrays-"swapped"-like-you-might-see-in-c/c++-code?)
- [What units are typically used in Devito examples](#What-are-units-typically-used-in-devito-examples)
- [How can I change the compilation flags (for example, I want to change the optimization level from -O3 to -O0)?](#How-can-I-change-the-compilation-flags-(for-example,-I-want-to-change-the-optimization-level-from--O3-to--O0)?)
- [Can I control the MPI domain decomposition?](#Can-I-control-the-MPI-domain-decomposition?)
- [Can I manually modify the C code generated by Devito and test these modifications?](#Can-I-manually-modify-the-C-code-generated-by-Devito-and-test-these-modifications?)


## How can I see the compilation command with which Devito compiles the generated code?
Set the environment variable `DEVITO_DEBUG_COMPILER=1`. When an Operator gets compiled, the used compilation command will be emitted to stdout. 

If nothing seems to change, it is possible that no compilation is happening under-the-hood as all kernels have already been compiled in a previous run. You will then have to clear up the Devito kernel cache. From the Devito root directory, run:
```
python scripts/clear_devito_cache.py
```

## Where does the generated code go and how do I look at it?
Devito stores the generated code as well as the jit-compiled libraries in a temporary directory. By setting the environment variable `DEVITO_LOGGING=DEBUG`, Devito will show, amongst other things, the absolute path to the generated code.


## Can I change the directory where Devito stashes the generated code?

Yes, just set the environment variable `TMPDIR` to your favorite location. 


## I create an Operator, look at the generated code, and the equations appear in a different order than I expected.

The Devito compiler computes a topological ordering of the input equations based on data dependency analysis. Heuristically, some equations might be moved around to improve performance (e.g., data locality). Therefore, the order of the equations in the generated code might be different than that used as input to the Operator.


## What environment variables control how Devito works
You can get the list of environment variables with the following python code:
```
from devito import print_defaults                                                                                                                                                                               
print_defaults()                                                                                                                                                                                                
```
And the output: **[NOTE: need a description of each of these]**
```
DEVITO_ARCH: ['custom', 'gnu', 'gcc', 'clang', 'pgcc', 'pgi', 'osx', 'intel', 'icpc', 'icc', 'intel-knl', 'knl', 'gcc-4.9', 'gcc-5', 'gcc-6', 'gcc-7', 'gcc-8', 'gcc-9']. Default: custom
DEVITO_PLATFORM: ['cpu64-dummy', 'intel64', 'snb', 'ivb', 'hsw', 'bdw', 'skx', 'klx', 'clx', 'knl', 'knl7210', 'arm', 'power8', 'power9', 'nvidiaX', 'cpu64']. Default: cpu64
DEVITO_PROFILING: ['basic', 'advanced', 'advisor']. Default: basic
DEVITO_BACKEND: ['core', 'yask', 'void', 'ops']. Default: core
DEVITO_DEVELOP: [False, True]. Default: True
DEVITO_DSE: ['basic', 'advanced', 'aggressive']. Default: advanced
DEVITO_DLE: ['noop', 'advanced', ('noop', 'C'), ('advanced', 'C')]. Default: advanced
DEVITO_OPENMP: [0, 1]. Default: 0
DEVITO_MPI: [0, 1, 'basic', 'diag', 'overlap', 'overlap2', 'full']. Default: 0
DEVITO_AUTOTUNING: ['off', 'basic', 'aggressive', 'max', ['off', 'preemptive'], ['off', 'destructive'], ['off', 'runtime'], ['basic', 'preemptive'], ['basic', 'destructive'], ['basic', 'runtime'], ['aggressive', 'preemptive'], ['aggressive', 'destructive'], ['aggressive', 'runtime'], ['max', 'preemptive'], ['max', 'destructive'], ['max', 'runtime']]. Default: off
DEVITO_LOGGING: ['DEBUG', 'PERF', 'YASK', 'YASK_WARN', 'INFO', 'WARNING', 'ERROR', 'CRITICAL']. Default: INFO
DEVITO_FIRST_TOUCH: [0, 1]. Default: 0
DEVITO_DEBUG_COMPILER: [0, 1]. Default: 0
DEVITO_JIT_BACKDOOR: [0, 1]. Default: 0
DEVITO_IGNORE_UNKNOWN_PARAMS: [0, 1]. Default: 0
```

## How do you run the unit tests from the command line
In addition to the [tutorials]( https://www.devitoproject.org/devito/tutorials.html), the unit tests provide an excellent way to see how the Devito API works with small self-contained examples. You can exercise individual unit tests with the following python code:
```
Py.test <test.py>
Py.test -vs <test.py>  [more detailed log]
```

## What is the difference between f() and f[] notation?
Devito offers a functional language to express finite difference operators. This is introduced [here](https://github.com/devitocodes/devito/blob/master/examples/userapi/01_dsl.ipynb) and systematically used throughout our examples and tutorials. The language relies on what in jargon we call the "f() notation".

```
>>> from devito import Grid, Function
>>> grid = Grid(shape=(5, 6))
>>> f = Function(name='f', grid=grid, space_order=2)
>>> f.dx
Derivative(f(x, y), x)
>>> f.dx.evaluate
-f(x, y)/h_x + f(x + h_x, y)/h_x
```

Sometimes, one wishes to escape the constraints of the language. Instead of taking derivatives, other special operations are required. Or perhaps, a specific grid point needs to be accessed. In such a case, one could use the "f[] notation" or "indexed notation". Following on from the example above:

```
>>> x, y = grid.dimensions
>>> f[x + 1000, y]
f[x + 1000, y]
```

The indexed object can be used at will to construct `Eq`s, and they can be mixed up with objects stemming from the "f() notation".

```
>>> f.dx + f[x + 1000, y]
Derivative(f(x, y), x) + f[x + 1000, y]
```

However, while the "f() notation" is substantially safe -- the language is designed such that only legal stencil expressions are built -- the "f[] notation" is not, and one can easily end up creating operators performing out-of-bounds accesses. So use it judiciously!


## What is the indexed notation? 

The indexed notation, or "f[] notation", is discussed [here](#What-is-the-difference-between-f()-and-f[]-notation?)


## Is there a flow chart?
**needs links**
1. Equation Lowering
  - Indexification
  - Substitutions
  - Domain alignment
  - Eq -> LoweredEq
2. Local Analysis
3. Clustering
4. Symbolic Optimization via Devito Symbolic Engine (DSE)
5. IET (Iteration/Expression Tree) Construction
6. IET Analysis
7. IET Optimization (DLE/YLE)
  - Loop optimization via Devito Loop Engine (DLE)
    - Loop Tiling / Cache Blocking
    - SIMD
    - OpenMP
    - MPI
8. Synthetic
9. JIT (Just In Time) Compilation


## What's up with <object>.data
The `.data` property which is associated with objects such as `Constant`, `Function` and `SparseFunction` (along with their derivatives) represents the 'numerical' value of the 'data' associated with that particular object. For example, a `Constant` will have a single numerical value associated with it as shown in the following snippet
```
from devito import Constant

c = Constant(name='c')
c.data = 2.7

print(c.data)
```
```
2.7
```
Then, a `Function` defined on a `Grid` will have a data value associated with each of the grid points (as shown in the snippet below) and so forth.
```
import numpy as np
from devito import Grid, Function

grid = Grid(shape=(4, 4), extent=(1, 1))
f = Function(name='f', grid=grid)
f.data[:] = np.arange(16).reshape(grid.shape)

print(f.data)
```
```
[[ 0.  1.  2.  3.]
 [ 4.  5.  6.  7.]
 [ 8.  9. 10. 11.]
 [12. 13. 14. 15.]]
```


## What are the keys to fast code
The code generated by devito is designed to run fast on CPU, GPU and clusters thereof. Broadly outlined, some of the mechanics for generating fast code are:
* CPU
  * Loop tiling (or "cache blocking")
  * Loop fusion (to maximize data locality)
  * Loop fission (to maximize parallelism)
  * Flop-reducing transformations (CSE, cross-stencil redundancies, factorization, hoisting)
  * OpenMP threading
  * OpenMP-based SIMD
  * Alignment to promote SIMD vectorization
* GPU
  * Longer pipelines, less travel to host (do more work on the GPU before communicating data between host and GPU)
* Clusters of CPUs/GPUs
  * Computation/communication overlap with prodding of the asynchronous progress engine
  * Avoidance of unnecessary halo exchanges
  * Reshuffling of halo exchanges
  * Threaded data packing/unpacking


## As time increases in the finite difference evolution, are wavefield arrays "swapped" as you might see in c/c++ code?

In c/c++ code using two wavefield arrays for second order acoustics, you might see code like the following to “swap” the wavefield arrays at each time step:
```
    float *p_tmp = p_old;
    p_old = p_cur;
    p_cur = p_tmp;
```

Instead of swapping arrays, devito uses the modulus of a time index to map increasing temporal indices [0, 1, 2, 3, 4, 5, ...] into cyclic indices [0, 1, 2, 0, 1, 2, ...].


## What units are typically used in Devito examples

- Sampling rates: msec
- Frequency: KHz
- Velocity: km/sec


## How can I change the compilation flags (for example, I want to change the optimization level from -O3 to -O0)?

There is currently no API to achieve this straightforwardly. However, there are three workarounds:

* hacky way: change the flags explicitly in the Devito source code. In Devito v4.0, you can do that [here](https://github.com/opesci/devito/blob/v4.0/devito/compiler.py#L146)
* via env vars: use a [CustomCompiler](https://github.com/opesci/devito/blob/v4.0/devito/compiler.py#L446) -- just leave the `DEVITO_ARCH` environment variable unset or set it to `'custom'`. Then, `export CFLAGS="..."` to tell Devito to use the exported flags in place of the default ones.
* programmatically: subclass one of the compiler classes and set `self.cflags` to whatever you need. Do not forget to add the subclass to the [compiler registry](https://github.com/opesci/devito/blob/v4.0/devito/compiler.py#L472). For example, you could do

```
from devito import configuration, compiler_registry
from devito.compiler import GNUCompiler

class MyOwnCompiler(GNUCompiler):
    def __init__(self, *args, **kwargs):
        super(MyOwnCompiler, self).__init__(*args, **kwargs)
        # <manipulate self.cflags here >


# Make sure Devito is aware of this new Compiler class
compiler_registry['mycompiler'] = MyOwnCompiler
configuration.add("compiler", "custom", list(compiler_registry), callback=lambda i: compiler_registry[i]())


# Then, what remains to be done is asking Devito to use MyOwnCompiler

configuration['compiler'] = 'mycompiler'
```


## Can I control the MPI domain decomposition?

Until Devito v3.5 included, domain decomposition occurs along the fastest axis. As of later versions, domain decomposition occurs along the slowest axis, for performance reasons.  And yes, it is possible to control the domain decomposition in user code, but this is undocumented and currently there exists no clean API to do that. However, below we provide some guidelines on how one can implement this.

* Start taking a look at the `Distributor` class, which controls the domain decomposition. In Devito v3.5, you can find it [here](https://github.com/opesci/devito/blob/v3.5/devito/mpi/distributed.py#L160).
* Turn the free function `compute_dims` into a `Distributor` method.
* In your user code, inherit from `Distributor` and override `compute_dims` at will. This will impact how the domain is decomposed along each of the distributed axes. 
* Change `Grid` to accept a `Distributor`, instead of `comm` (an MPI communicator). In Devito v3.5, you can do it [here](https://github.com/opesci/devito/blob/v3.5/devito/types/grid.py#L100).
* In your user code, create a `Grid` passing in an instance of the sub-classed `Distributor`, that is you should have `grid = Grid(...., distributor=MyDistributor(...))`.


## Can I manually modify the C code generated by Devito and test these modifications?

Yes, as of Devito v3.5 it is possible to modify the generated C code and run it inside Devito. First you need to get the C file generated for a given `Operator`. Run your code in `DEBUG` mode:
```
DEVITO_LOGGING=DEBUG python your_code.py
```
The generated code path will be shown as in the excerpt below:
```
CustomCompiler: compiled `/tmp/devito-jitcache-uid1000/ed41e9373af1bc129471b7ae45e1c3740b60a856.c` [0.29 s]
```
You can now open the C file, do the modifications you like, and save them. Finally, rerun the same program but this time with the _Devito JIT backdoor_ enabled:
```
DEVITO_JIT_BACKDOOR=1 python your_code.py
```
This will force Devito to recompile and link the modified C code.
